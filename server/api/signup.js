const {
  checkUsernameServer,
  checkPasswordServer,
} = require("../../utilities/AccountValidators");
const { db } = require("../db");
const Crypto = require("crypto");
const { login } = require("./login");

/**
 * The callback function for the /api/signup POST route. Signs up a user into the database.
 *
 * The `req` parameter should contain both `username` and `password` in its body.
 * @param {Express.Request} req - The Request object generated by the route.
 * @param {Express.Response} res - The Response object generated by the route.
 * @param {Function} next - The next() function used in the callback.
 * @returns Nothing.
 */
function signup(req, res, next) {
  var { username, password } = req.body;

  // check that signup data is real
  if (!username || !password) {
    res.status(400).send("Error: Username or password not set!");
    return;
  }

  // test username and password; should throw an error if there's an issue
  try {
    checkUsernameServer(username);
    checkPasswordServer(password);
  } catch (error) {
    res.status(400).send(error.message);
    return;
  }

  const salt = Crypto.randomBytes(16); // salt is required for hashing; it makes
  // otherwise identical hashes different
  Crypto.pbkdf2(
    password,
    salt,
    310000,
    32,
    "sha256",
    async function (err, hashedPassword) {
      if (err) {
        return res.status(500).send(err);
      }

      // insert new user into database
      await insertUser(
        db,
        username,
        hashedPassword,
        salt,
        (err, user) => {
          if (err) {
            // 19 is SQLITE_CONSTRAINT, should be username constraint
            if (err.errno == 19) {
              res.status(400).send("Error: Username already exists!")
            } else { // idk how to test for this branch
              res
                .status(500)
                .send(`Error: Failed to insert new user!\nSpecific error: ${err}`);
            }
            return; // end prematurely
          }
          // TODO (integration): After correctly signing up, log the user in
          login(req, res, next);
        }
      )
    }
  );
}

/**
 * Inserts a new User into the database `db`. Calls a callback on the new user object afterwards.
 * @param {Database} db - The database to insert the User into.
 * @param {String} username - The username of the new User.
 * @param {Buffer} hashedPassword - The hashed password of the new User. This (hopefully) should be generated by `Crypto.pbkdf2()`.
 * @param {String} salt - The salt used in hashing the password.
 * @param {Callback} callback - A callback which handles what happens after inserting the user.
 *                   Should take in two arguments: an error `error` and the `user` object generated from `insertUser`.
 *                   `user` will be an empty object if an error is thrown, and `error` will be null if there is no error.
 * @returns Nothing.
 */
async function insertUser(db, username, hashedPassword, salt, callback) {
  await db.run(
    "INSERT INTO User (username, hashed_password, salt) VALUES (?, ?, ?)",
    [username, hashedPassword, salt],
    function (err) {
      var user = {};

      // throw an error if there's an issue
      if (err) {
        callback(err, user);
        return;
      }

      // create a user object, handle it elsewhere
      // TODO: Perhaps this should also generate a user token at this time?
      user = {
        user_id: this.lastID,
        username: username,
      };

      callback(err, user);
    }
  );
}

module.exports = { signup, insertUser };
